<html>
<head>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="/socket.io/socket.io.js"></script>
<style>
  .link {
    fill:none;
    stroke-opacity: .5;
  }

  .label {
    font-family:Arial;
    font-size:10pt;
    font-weight:bold;
    text-anchor:middle;
    stroke:white;
    stroke-width:0.4px;
  }

  .call {
    font-family:Arial;
    font-size:14pt;
  }

  textarea {
    font-size:12pt;
  }

</style>
</head>
<body>
<script type="text/javascript">
  //socket.io
  var socket = io.connect('/');
  var q = {};
  var qIndex = 0;

  socket
    .on('sysCalls', function(data) {
      var i = data.index;
      var content = data.content;
      q[i] = content;
    })
    .on('stdout', function(data) {
      csPrint(data.content.join('\n'))
    });

  //ui
  var b = d3.select(document.body);
  var w = window.innerWidth;
  var h = window.innerHeight;

  var panelWidth = 300;

  var leftPanel = b.append('div')
    .style('position','absolute')
    .style('width',panelWidth)
    .style('height',h)
    .style('top',0)
    .style('left',0)
    .style('background','#D9D9D9');

    var cons = leftPanel.append('div');
      var display = cons.append('textarea')
        .attr('readonly','readonly')
        .style('position','absolute')
        .style('top',10)
        .style('left',10)
        .style('width', parseInt(leftPanel.style('width')) - 20)
        .style('height', parseInt(leftPanel.style('height')) - 60)
        .style('background','#F5F5F5')
        .style('resize','none')
        .style('outline','none');

      var input = leftPanel.append('input')
        .attr('type','text')
        .style('position','absolute')
        .style('top', parseInt(leftPanel.style('height')) - 40)
        .style('left',10)
        .style('height',20)
        .style('border',0)
        .style('outline','none')
        .style('width', parseInt(leftPanel.style('width')) - 20)
        .on('keydown', function() {
          if (d3.event.keyCode == 13) {
            csPrint('>' + this.value)
            if (this.value[0] == "\\") {
              var args = this.value.substring(1,this.value.length).split(' ');
              if (commands[args[0]] != undefined) {
                commands[args[0]](args);
              } else {
                csPrint('!! command does not exist !!')
              }
            } else {
              socket.emit('strace', { val: this.value });
            }
            this.value = '';
          }
        });

  //console commands
  var commands = {
    'clearGraph':function() {
      nodeIndex = {};
      linkIndex = {};
      lastCall = 'START';
      force
        .stop()
        .nodes([])
        .links([]);

      render();
    },
    'clearConsole': function() {
      display.node().value = '';
    },
    'clear':function() {
      this.clearGraph();
      this.clearConsole();
    },
    'node':function(args) {
      var name = args[1];
      if (nodeIndex[name] != undefined) {
        var out = '';
        out += name + '\ncount: ' + nodeIndex[name].count + "\n";
        for (var i = 0 ; i < force.links().length ; i ++ ) {
          var l = force.links()[i];
          if (l.source.call == name) {
            out += 'link to "' + l.target.call + '" count: ' + l.count + "\n";
          }
        }
        csPrint(out);
      } else {
        csPrint('!! no node named: ' + name + ' found !!');
      }
    },
    'startPos':function(args) {
      if (args[1] == "center") {
        startPos = [(w - panelWidth) / 2, h / 2];
      } else {
        startPos = [parseInt(args[1]), parseInt(args[2])];
      }
      
      force.resume();
    },
    'endPos':function(args) {
      if (args[1] == "center") {
        endPos = [(w - panelWidth) / 2, h / 2];
      } else {
        endPos = [parseInt(args[1]), parseInt(args[2])];
      }
      render();
      force.resume();
    },
    'stop':function() {
      socket.emit('stop',{});
    }
  };

  //d3
  var svg = b.append('svg')
    .style('position','absolute')
    .style('width',w - panelWidth)
    .style('height',h)
    .style('top',0)
    .style('left',panelWidth)
    .on('mousedown', function() {
      d3.event.preventDefault();
    });
  var link = svg.selectAll(".link");
  var node = svg.selectAll(".node");
  var label = svg.selectAll(".label");

  var nodeIndex = {};
  var linkIndex = {};
  var lastCall = "START";

  var startPos = [100,100];
  var endPos = [w - panelWidth - 75, h - 75];

  var squareSize = 50;
  var square = svg.append("rect")
    .attr('width', squareSize)
    .attr('height', squareSize)
    .attr('x', (endPos[0] - squareSize))
    .attr('y', (endPos[1] - squareSize))
    .style('stroke', '#474747')
    .style('stroke-width',2)
    .attr('fill', 'none')
    .attr('class','square');

  var force = d3.layout.force()
    .size([w, h - 50])
    .nodes([])
    .links([])
    .linkDistance(150)
    .charge(-600)
    .on('tick', tick);

  var scale = {
    radius:null,
    stroke_link:null,
    stroke_self:null,
    color:null,
  };

  function parseData(d) {
    //parse
    for (var i = 0 ; i < d.length ; i ++ ) {
      var current = d[i];

      if (nodeIndex[current.call] == undefined) {
        var item = {
          "call":current.call,
          "count":1,
        };

        nodeIndex[current.call] = item;
        force.nodes().push(item);

      } else {
        nodeIndex[current.call].count += 1;
      }

      if (lastCall != "START") {
        var linkKey = [lastCall.call,current.call];

        if (linkIndex[linkKey] == undefined) {
          var item = {
            "source":nodeIndex[lastCall.call],
            "target":nodeIndex[current.call],
            "count":1
          };

          linkIndex[linkKey] = item;
          force.links().push(item); 
        } else {
          linkIndex[linkKey].count += 1;
        }
      } else {
        var startNode = {
          "call":"START",
          "count":1,
        }

        var item = {
          "source":startNode,
          "target":nodeIndex[current.call],
          "count":1
        };

        nodeIndex["START"] = startNode;
        force.nodes().push(startNode)

        linkIndex[["START",current.call]] = item;
        force.links().push(item); 
      }

      lastCall = current;
    }

    force.start();
  }

  function init() {
    scale.radius = d3.scale.linear().domain([1,d3.max(force.nodes(),function(d) { return d.count; })]).range([8,30]);
    scale.stroke = d3.scale.linear().domain([1,d3.max(force.links(),function(d) { return d.count; })]).range([2,20]);
    scale.stroke_self = d3.scale.log().domain([1,d3.max(force.links(),function(d) { return d.count; })]).range([2,10]);
    scale.color = d3.scale.category20();
  }

  function render() {
    square
      .attr('x', (endPos[0] - squareSize / 2))
      .attr('y', (endPos[1] - squareSize / 2))

    link = link.data(force.links(), function(d) { return d.source.call + "-" + d.target.call; });
    node = node.data(force.nodes(), function(d) { return d.call;});
    label = label.data(force.nodes(), function(d) { return d.call;});

    link.enter().insert('line', '.node')
      .attr('class','link')
      .style('stroke', function(d,i) {
        return colorHash(d.source.call);
      })
      .style("stroke-width", function(d,i) {
        return scale.stroke(d.count);
      })
      .attr("stroke-dasharray", "5, 10");

    node.enter().insert('circle')
      .attr("class", "node")
      .attr("r", function(d) {
        return d.count ? scale.radius(d.count) : 0;
      })
      .attr("fill", function(d,i) {
        return colorHash(d.call);
      })
      .on('dblclick', function(d) {
        manPageLinker(d);
      });
    
    node
      .call(force.drag);

    label.enter().append('text')
      .attr('class','label')
      .text(function(d) {
        return d.call;
        })
      .on('dblclick', function(d) {
          manPageLinker(d);
       });

    node.exit().remove();
    link.exit().remove();
    label.exit().remove();
  } 

  function tick() {
    link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

    node
      .attr("cx", function(d) {
        return d.x;
        })
      .attr("cy", function(d) {
        return d.y;
      })
      .attr('stroke', function(d,i) {
        if (d.call == lastCall.call) {
          //d.x += ((w - panelWidth)/2 - d.x) * 0.1
          //d.y += (h/2 - d.y) * 0.1
          d.x += (endPos[0] - d.x) * 0.1
          d.y += (endPos[1] - d.y) * 0.1
          return '#A12A2A';
        } else {
          return 'none';
        }
      })
      .attr('stroke-width', function(d,i) {
        if (d.call == lastCall.call) {
          return 3;
        } else {
          return 0;
        }
      })
      .each(function(d,i) {
        if (d.call == 'START') {
          d.x += (startPos[0] - d.x) * 0.1;
          d.y += (startPos[1] - d.y) * 0.1;
        }
      });

    label
      .attr('x', function(d) { return d.x; })
      .attr('y', function(d) { return d.y + scale.radius(d.count) + 15; });
 }

  //util
 function colorHash(str) {
      // str to hash
    for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash));

      // int/hash to hex
    for (var i = 0, colour = "#"; i < 3; colour += ("00" + ((hash >> i++ * 8) & 0xFF).toString(16)).slice(-2));

    return colour;
  }

 function manPageLinker(d) {
    if (d.call == "START" | d.call == "END" | d.call == "") {
      return;
      } else {
      window.open('http://man7.org/linux/man-pages/man2/' + d.call + '.2.html', '_blank');
    }
  }  

  var dashTick = 0;
  function animator(){
    dashTick -= .1;
    dashTick = dashTick % 10000;
    link.attr("stroke-dashoffset", dashTick.toString() + "%");
  }  

  function processData() {
    if (q[qIndex] != undefined) {
      var data = q[qIndex];
      parseData(data);
      qIndex ++;
      init();
      render();
    }
  }

  function csPrint(str) {
    display.node().value += str.trim() + "\n\n";
    display.node().scrollTop = display.node().scrollHeight;
  }

  //main
  window.setInterval(animator, 66);
  window.setInterval(processData,200);
</script>
</body>
 
</html>
