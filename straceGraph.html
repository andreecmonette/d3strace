<html>
<head>
  <!-- <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->
  <script src="/d3.v3.min.js" charset = "utf-8"></script>
  <!-- For local testing --> 
<script src="/socket.io/socket.io.js"></script>
<style>
  .link {
    fill:none;
    stroke-opacity: .5;
  }

  .label {
    font-family:Arial;
    font-size:8pt;
    font-weight:bold;
    text-anchor:middle;
    stroke:white;
    stroke-width:0.4px;
  }

</style>
</head>
<body>
<script type="text/javascript">
  ///core functions
  var links = [];
  var nodes = [];
  var nodeIndex = {};
  var linkIndex = {};
  var lastCall = "START";
  var LARGEPRIME = 32452843;
  function colorHash(str) {
   k = 1;
   for (chr in str) {
     k *= str.charCodeAt(chr);
   } 
     k = k % LARGEPRIME;
     return (k % 0xffffff).toString(16);
   }

  //ui
  var b = d3.select(document.body);
  var topBar = b.append('div')
    .style('position','absolute');
  var inputProcess = topBar.append('input')
      .style('position','absolute')
      .attr('type','text');
  var submit = topBar.append('button')
      .style('position','absolute');
  var terminal = b.append('div')
      .style('position','absolute');
  var svg = b.append('svg')
      .style('position','absolute');
  var link = svg.selectAll(".link");
  var node = svg.selectAll(".node");
  var selfRef = svg.selectAll(".selfLink");
  var label = svg.selectAll(".label");

  var w = window.innerWidth;
  var h = window.innerHeight;

  topBar
    .style('width',w)
    .style('height',45)
    .style('background','black')
    .style('top',0)
    .style('left',0);

  inputProcess
    .style('width',160)
    .style('top',10)
    .style('left',20);

  submit
    .style('width',60)
    .style('height',22)
    .style('top',10)
    .style('left',190)
    .text('submit');
  
  terminal
    .style('width', 180)
    .style('height', h-50)
    .style('top', 50)
    .style('left', 0)
    .style('font-family', 'monospace');
  
  svg
    .style('width',w-180)
    .style('height',h-50)
    .style('top',50)
    .style('left',180)
    .on('mousedown', function() {
      d3.event.preventDefault();
      });
  var squareSize = 50;
  var square = svg.append("rect")
    .attr('width', squareSize)
    .attr('height', squareSize)
    .attr('x', (w - squareSize)/2)
    .attr('y', (h - squareSize)/2)
    .style('stroke', 'black')
    .attr('fill', 'none');
  var force = d3.layout.force()
    .size([w-180, h - 50])
    .nodes(nodes)
    .links(links)
    .linkDistance(150)
    .charge(function(d,i) {
      return -700; 
    })
    .on('tick', tick);

  var scale = {
    radius:null,
    stroke_link:null,
    stroke_self:null,
    color:null,
  };

  //socket.io
  var socket = io.connect('/');
  var q = {};
  var qIndex = 0;
  var stdOut = "";

  socket.on('stdOutData', function(data) {
    console.log(data);  
    var i = data.index;
    var content = data.content;
    // for now
    stdOut = stdOut + content;
    //console.log(stdOut);
    //console.log(stdOut.split('\n').slice(stdOut.length - 20,stdOut.length));
    //terminal.text(stdOut.split('\n').slice(stdOut.length - 20,stdOut.length));
    terminal.text(stdOut);
  });

  socket.on('sysCalls', function(data) {
    var i = data.index;
    var content = data.content;
    q[i] = content;
  });

  submit
    .on('click', function() {
      socket.emit('strace', { val: inputProcess.node().value });
    });

  function parseData(d) {
    //parse
    for (var i = 0 ; i < d.length ; i ++ ) {
      var current = d[i];

      if (nodeIndex[current.call] == undefined) {
        nodeIndex[current.call] = nodes.length;
        nodes.push({
          "call":current.call,
          "count":1,
        })
      } else {
        nodes[nodeIndex[current.call]].count += 1;
      }

      if (lastCall != "START") {
        var linkKey = [lastCall.call,current.call];

        if (linkIndex[linkKey] == undefined) {
          linkIndex[linkKey] = links.length;
          links.push({
            "source":nodes[nodeIndex[lastCall.call]],
            "target":nodes[nodeIndex[current.call]],
            "count":1
          }); 
        } else {
          links[linkIndex[linkKey]].count += 1;
        }
      } else {
        nodeIndex["START"] = nodes.length;
        nodes.push({
          "call":"START",
          "count":1,
        })

        linkIndex[["START",current.call]] = links.length;
        links.push({
          "source":nodes[nodeIndex["START"]],
          "target":nodes[nodeIndex[current.call]],
          "count":1
        }); 
      }

      lastCall = current;
    }
  }

  function init() {
    scale.radius = d3.scale.linear().domain([1,d3.max(nodes,function(d) { return d.count; })]).range([8,30]);
    scale.stroke = d3.scale.linear().domain([1,d3.max(links,function(d) { return d.count; })]).range([2,20]);
        //,200]).range([2,20]).clamp(true);
        //
    scale.stroke_self = d3.scale.log().domain([1,d3.max(links,function(d) { return d.count; })]).range([2,10]);
    scale.color = d3.scale.category20();
  }

  function render() {
    force.start();
    //console.log(force.links());
    link = link.data(force.links(), function(d) { return d.source.call + "-" + d.target.call; });
    node = node.data(force.nodes(), function(d) { return d.call;});
    //selfRef = selfRef.data(force.nodes(), function(d) { return d.id;});
    label = label.data(force.nodes(), function(d) { return d.call;});

    link.enter().insert('line', '.node')
      .attr('class','link')
      .style('stroke', function(d,i) {
        return scale.color(d.source.color);
      })
      .style("stroke-width", function(d,i) {
        return scale.stroke(d.count);
      })
      .attr("stroke-dasharray", "5, 10");

    node.enter().append('circle')
      .attr("class", "node")
      .transition()
      .attr("r", function(d) {
        return d.count ? scale.radius(d.count) : 0;
      })
      .attr("fill", function(d,i) {
        return "#" + colorHash(d.call);
      });
    
    node
      .call(force.drag);

    label.enter().append('text')
      .attr('class','label')
      .text(function(d) {
        return d.call;
        })
      .on('dblclick', function(d) {
          manPageLinker(d);
       });
/*
    selfRef.enter().append('circle')
      .style('display', function(d) {
        return d.selfRef ? 'block' : 'none';
      })
      .attr("r", function(d) {
        return d.count ? scale.radius(d.count) : 0;
      })
      .attr('stroke', function(d) {
        return scale.color(d.color);
      })
      .attr('stroke-width', function(d) {
        return scale.stroke_self(d.selfRefCount);
      })
      .attr('fill','none')
      .attr("stroke-dasharray", "5, 10");
*/

    function manPageLinker(d) {
      if (d.call == "START" | d.call == "END" | d.call == "") {
        return;
        } else {
        window.open('http://man7.org/linux/man-pages/man2/' + d.call + '.2.html', '_blank');
      }
    }

    node
      .on('dblclick', function(d) {
        manPageLinker(d);
      });
    
  } 

  var thetick = 0;
  function animator(){
    thetick -= .1;
    thetick = thetick % 10000;
    link.attr("stroke-dashoffset", thetick.toString() + "%");
    selfRef.attr("stroke-dashoffset", thetick.toString() + "%");
  }

  window.setInterval(animator, 66);

  function tick() {
    link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

    node
      .attr("cx", function(d) {
        return d.x;
        })
      .attr("cy", function(d) {
        return d.y;
      })
      .attr('stroke', function(d,i) {
        if (d.call == lastCall.call) {
        d.x += (w/2 - d.x) * 0.1
        d.y += (h/2 - d.y) * 0.1
          return 'red';
        } else {
          return 'none';
        }
      });
/*
    selfRef
      .attr("transform", function(d) {
        return "translate(" + (d.x + scale.radius(d.count) * 0.7) + "," + (d.y - scale.radius(d.count) * 0.7) + ")";
      });
*/
    label
      .attr('x', function(d) { return d.x; })
      .attr('y', function(d) { return d.y + scale.radius(d.count) + 10; });
 }

 function processData() {
    if (q[qIndex] != undefined) {
      var data = q[qIndex];
      parseData(data);
      qIndex ++;
      init();
      render();
    }
  }

  window.setInterval(processData,200);

</script>
</body>
 
</html>
