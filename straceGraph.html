<html>
<head>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="/socket.io/socket.io.js"></script>
<style>
  .link {
    fill:none;
    stroke: #999;
    stroke-opacity: .5;
  }

  .node {
    font-family:Arial;
    font-size:8pt;
    font-weight:bold;
    text-anchor:middle;
    stroke:white;
    stroke-width:0.4px;
  }
</style>
</head>
<body>
	<input id='call' type='text'/>
  <button id='submit'>
<script type="text/javascript">
  var socket = io.connect('/');
  /*
  function handleFileSelect(evt) {
    var files = evt.target.files;
    var output = [];
    for (var i = 0, f; f = files[i]; i++) {
      var reader = new FileReader();
      reader.onload = function(e) {
        var lines = reader.result.split('\n');
        parseLines(lines);
      }
      reader.readAsText(f);
    }
  }

  document.getElementById('files').addEventListener('change', handleFileSelect, false);
  */

  var input = d3.select(document.getElementById('call'));
  var submit = d3.select(document.getElementById('submit'));
  var q = {};
  var qi = 0;
  input
    .style('position','absolute')
    .style('top',height + 10)
    .style('left',0);

  submit
    .style('position','absolute')
    .style('top',height + 10)
    .style('left',50);

  document.getElementById('submit').addEventListener('click', function() {
        socket.emit('strace', { val: document.getElementById('call').value });
      });
      socket.on('sysCalls', function(data) {
        var d = data.content;
        var i = data.index;

        q[i] = d;

      });

  function process() {
    if (q[qi] != undefined) {
      var data = q[qi];

      parseData(data);

      qi++;
    }
  }

  setInterval(process, 200);

  var width = window.innerWidth;
  var height = window.innerHeight - 50;

  var index = {};
  var nodes = [];
  var links = [];
  var lastCall = null;

  var svg = d3.select(document.body).append("svg")
      .style('position','absolute')
      .style('top',0)
      .style('left',0)
      .attr("width", width)
      .attr("height", height);
  
  var nodeColor = d3.scale.category20();
  var radiusScale;
  var strokeScale;
  var selfStrokeScale;
  var force = d3.layout.force()
    .linkDistance(50)
    .size([width,height])
  var link;
  var node;
  var selfRef;
  var label;

  function parseData(d) {
    for (var i = 0  ; i < d.length ; i ++ ) {
      
    }
  };

  /*
  function parseLines(l) {
    l.push("END");
    l.unshift("START");
    var nodeCount = {};
    var linkCount = {};

    for (var i = 0; i < l.length; i++) {
      if (nodeCount[l[i]] === undefined) {
        nodeCount[l[i]] = 1;
      } else {
        nodeCount[l[i]] += 1;
      }
      if (i + 1 < l.length) {

        var key = [l[i], l[i+1]];
        if (linkCount[key] === undefined) {
          linkCount[key] = 1;
        } else {
          linkCount[key] += 1;
        }
      }
    }
    var data = {};
    var count = 0;
    for (key in nodeCount) {
      index[key] = count;
      count ++;
      nodes.push({
          "name":key,
          "count":nodeCount[key],
          "color":count,
          "charge":-1000
        }
      );
    }
    for (key in linkCount) {
      var pair = key.split(",");
      if (pair[0] == pair[1]) {
        nodes[index[pair[0]]].selfRef = true;
        nodes[index[pair[0]]].selfRefCount = linkCount[key];
      } else {
        links.push({

          "source":index[pair[0]],
          "target":index[pair[1]],
          "count":linkCount[key]
        });      
      }
    }

    radiusScale = d3.scale.log().domain([1,d3.max(nodes,function(d) { return d.count; })]).range([5,20]);
    strokeScale = d3.scale.linear().domain([1,d3.max(links,function(d) { return d.count; })]).range([1,20]);
    selfStrokeScale = d3.scale.log().domain([1,d3.max(links,function(d) { return d.count; })]).range([1,10]);

    render();
  }
  */

  function initialize() {
    
  }

  function render() { 
    force
      .nodes(nodes)
      .links(links)
      .linkDistance(150)
      .charge(function(d,i) {
        return d.charge;
      })
      .start();

    link = svg.selectAll(".link")
      .data(links)
      .enter().append("line")
      .attr('class','link')
      .style('stroke', function(d,i) {
        return nodeColor(d.source.color);
      })
      .style("stroke-width", function(d,i) {
        return strokeScale(d.count);
      })
      .attr("stroke-dasharray", "5, 10");

    node = svg.selectAll(".node")
      .data(nodes)
      .enter().append("circle")
      .attr("r", function(d) {
        return d.count ? radiusScale(d.count) : 0;
      })
      .style("fill", function(d,i) {
        return nodeColor(d.color);
      })
      .call(force.drag);

    selfRef = svg.selectAll(".node")
      .data(nodes)
      .enter().append("circle")
      .style('display', function(d) {
        return d.selfRef ? 'block' : 'none';
      })
      .attr("r", function(d) {
        return d.count ? radiusScale(d.count) : 0;
      })
      .attr('stroke', function(d) {
        return nodeColor(d.color);
      })
      .attr('stroke-width', function(d) {
        return selfStrokeScale(d.selfRefCount);
      })
      .attr('fill','none')
      .attr("stroke-dasharray", "5, 10");

    function manPageLinker(d) {
      if (d.name == "START" | d.name == "END" | d.name == "") {
        return;
        } else {
        window.open('http://man7.org/linux/man-pages/man2/' + d.name + '.2.html', '_blank');
      }
    }

    node
      .on('dblclick', function(d) {
        manPageLinker(d);
      })

    label = svg.selectAll('.node')
      .data(nodes)
      .enter().append('text')
      .attr('class','node')
      .text(function(d) {
        return d.name;
      });

    force.on("tick", function() {
      link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

      node.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      });

      selfRef
        .attr("transform", function(d) {
          return "translate(" + (d.x + radiusScale(d.count) * 0.7) + "," + (d.y - radiusScale(d.count) * 0.7) + ")";
        });

      label
        .attr('x', function(d) { return d.x; })
        .attr('y', function(d) { return d.y + radiusScale(d.count) + 10; });
    })

    var thetick = 0;
    function animator(){
      thetick -= .1;
      thetick = thetick % 10000;
      link.attr("stroke-dashoffset", thetick.toString() + "%");
      selfRef.attr("stroke-dashoffset", thetick.toString() + "%");
    }

    window.setInterval(animator, 66);
  }

</script>
</body>
 
</html>
