<html>
<head>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="/socket.io/socket.io.js"></script>
<style>
  .link {
    fill:none;
    stroke-opacity: .5;
  }

  .node {
    font-family:Arial;
    font-size:8pt;
    font-weight:bold;
    text-anchor:middle;
    stroke:white;
    stroke-width:0.4px;
  }

</style>
</head>
<body>
<script type="text/javascript">
  //ui
  var b = d3.select(document.body);
  var topBar = b.append('div')
    .style('position','absolute');
    var inputProcess = topBar.append('input')
      .style('position','absolute')
      .attr('type','text');
    var submit = topBar.append('button')
      .style('position','absolute');
   var svg = b.append('svg')
 //   .style('position','absolute');

  var w = window.innerWidth;
  var h = window.innerHeight;

  topBar
    .style('width',w)
    .style('height',45)
    .style('background','black')
    .style('top',0)
    .style('left',0);

  inputProcess
    .style('width',100)
    .style('top',10)
    .style('left',20);

  submit
    .style('width',60)
    .style('height',22)
    .style('top',10)
    .style('left',130)
    .text('submit');

  svg
    .style('width',w)
    .style('height',h-50)
    .style('top',50)
    .style('left',0)

  var force = d3.layout.force();
  var scale = {
    radius:null,
    stroke_link:null,
    stroke_self:null,
    color:null,
  };

  //socket.io
  var socket = io.connect('/');
  var q = {};
  var qIndex = 0;

  socket.on('sysCalls', function(data) {
    var i = data.index;
    var content = data.content;
    q[i] = content;
  });

  submit
    .on('click', function() {
      socket.emit('strace', { val: inputProcess.node().value });
    });

  ///core functions
  var link;
  var node;
  var selfRef;
  var label;

  var links = [];
  var nodes = [];
  var nodeIndex = {};
  var linkIndex = {};
  var lastCall = "START";

  function parseData(d) {
    //parse
    for (var i = 0 ; i < d.length ; i ++ ) {
      var current = d[i];

      if (nodeIndex[current.call] == undefined) {
        nodeIndex[current.call] = nodes.length;
        nodes.push({
          "call":current.call,
          "count":1,
        })
      } else {
        nodes[nodeIndex[current.call]].count += 1;
      }

      if (lastCall != "START") {
        var linkKey = [lastCall.call,current.call];

        if (links[linkKey] == undefined) {
          linkIndex[linkKey] = links.length;
          links.push({
            "source":nodeIndex[lastCall.call],
            "target":nodeIndex[current.call],
            "count":1
          }); 
        } else {
          links[linkIndex[linkKey]].count += 1;
        }
      } else {
        nodeIndex["START"] = nodes.length;
        nodes.push({
          "call":"START",
          "count":1
        })

        linkIndex[["START",current.call]] = links.length;
        links.push({
          "source":nodeIndex["START"],
          "target":nodeIndex[current.call],
          "count":1
        }); 
      }

      lastCall = current;
    }
  }

  function init() {
    scale.radius = d3.scale.log().domain([1,d3.max(nodes,function(d) { return d.count; })]).range([5,20]);
    scale.stroke = d3.scale.linear().domain([1,d3.max(links,function(d) { return d.count; })]).range([1,20]);
    scale.stroke_self = d3.scale.log().domain([1,d3.max(links,function(d) { return d.count; })]).range([1,10]);
    scale.color = d3.scale.category20();
  }

  function render() {
  

    link = svg.selectAll(".link")
      .data(links);
    link.enter().append("line")
      .attr('class','link')
      .style('stroke', function(d,i) {
        return scale.color(d.source.color);
      })
      .style("stroke-width", function(d,i) {
        return scale.stroke(d.count);
      })
      .attr("stroke-dasharray", "5, 10");

    node = svg.selectAll(".node")
      .data(nodes);
    node.enter().append("circle")
      .attr("r", function(d) {
        return d.count ? scale.radius(d.count) : 0;
      })
      .style("fill", function(d,i) {
        return scale.color(d.color);
      })
      .call(force.drag);

    selfRef = svg.selectAll(".node")
      .data(nodes)
      .enter().append("circle")
      .style('display', function(d) {
        return d.selfRef ? 'block' : 'none';
      })
      .attr("r", function(d) {
        return d.count ? scale.radius(d.count) : 0;
      })
      .attr('stroke', function(d) {
        return scale.color(d.color);
      })
      .attr('stroke-width', function(d) {
        return scale.stroke_self(d.selfRefCount);
      })
      .attr('fill','none')
      .attr("stroke-dasharray", "5, 10");

    function manPageLinker(d) {
      if (d.name == "START" | d.name == "END" | d.name == "") {
        return;
        } else {
        window.open('http://man7.org/linux/man-pages/man2/' + d.name + '.2.html', '_blank');
      }
    }

    node
      .on('dblclick', function(d) {
        manPageLinker(d);
      })

    label = svg.selectAll('.node')
      .data(nodes)
      .enter().append('text')
      .attr('class','node')
      .text(function(d) {
        return d.call;
      });

    
    var thetick = 0;
    function animator(){
      thetick -= .1;
      thetick = thetick % 10000;
      link.attr("stroke-dashoffset", thetick.toString() + "%");
      selfRef.attr("stroke-dashoffset", thetick.toString() + "%");
    }

    window.setInterval(animator, 66);
  } 
  force
      .nodes(nodes)
      .links(links)
      .linkDistance(150)
      .charge(function(d,i) {
        return d.charge;
      })
      .start();
 
    force.on("tick", function() {
      link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

      node.attr("transform", function(d) {
        return "translate(" + d.x + "," + d.y + ")";
      });

      selfRef
        .attr("transform", function(d) {
          return "translate(" + (d.x + scale.radius(d.count) * 0.7) + "," + (d.y - scale.radius(d.count) * 0.7) + ")";
        });

      label
        .attr('x', function(d) { return d.x; })
        .attr('y', function(d) { return d.y + scale.radius(d.count) + 10; });
    });
 function processData() {
    if (q[qIndex] != undefined) {
      var data = q[qIndex];
      parseData(data);
      init();
      
      render();
      qIndex ++;
    }

  }

  window.setInterval(processData,200);

</script>
</body>
 
</html>
